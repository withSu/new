---
layout: single
title:  "#1 릴레이션 정규화"
categories: database
tag: database
toc: true
toc_label: "table of content" # toc 이름 설정
toc_icon: "bars" # 아이콘 설정
toc_sticky: true # 마우스 스크롤과 함께 내려갈 것인지 설정
typora-root-url: ../
---

# 1. 릴레이션 정규화

부주의한 데이터베이스 설계는 `제어할 수 없는 데이터 중복을 야기`하여 `여러가지 갱신이상을 유발`함

- 어떻게 좋은 데이터베이스  설계를 할 것인가?
- 데이터베이스에 어떤 릴레이션들을 생성할것인가?
- 각 릴레이션에 어떤 에트리뷰트를 둘것인

## 릴레이션 정규화?

`정규화`는 주어진 릴레이션 스키마를 `함수적 종속성`과 `기본키`를 기반으로 분석하여, `원래의 릴레이션을 분해`함으로써 중복과 세가지 갱신이상을 최소화함.

적절하게 정규화된 릴레이션들은 데이터베이스의 유지를 간단하게 함.

# 2. 정규화 개요

## 2.1 좋은 관계 데이터베이스 스키마를 설계하는 목적

- `정보의 중복과 갱신 이상이 생기지 않도록` → 정규화
- `정보의 손실`을 막음
- 실세계를 훌륭하게 나타내고
- 애트리뷰트들 간의 관계가 잘 표현되는 것을 보장하며
- 어떤 무결성 제약조건의 시행을 간단하게 하며
- 아울러 효율성 측면도 고려하는것

- 실세계를 훌륭하게 나타낸 설계는 직관적으로 이해하기 쉬우며, 미래의 성장에 잘 대비할 수 있는 설계를 의미.
- `먼저 갱신 이상이 발생하지 않도록 노력`하고, 그다음에 효율성르 고려함.

## 2.2 세가지 갱신 이상 (update anomoly)

정규화과정에서 해결하고자하는 갱신이상에 대하여 설명.

갱신이상은 데이터베이스에서 비정규화된 구조로 인해 발생할 수 있는 문제점으로, 세가지 유형이 있다.

### 2.2.1 수정 이상 (modification anomoly)

`반복된 데이터 중에 일부만 수정하면 데이터의 불일치가 발생`

### 2.2.2 삽입 이상 (insertion anomoly)

`불필요한 정보를 함께 저장하지 않고는` 어떤 정보를 저장하는 것이 불가능

### 2.2.3 삭제 이상 (deletion anomoly)

`유용한 정보를 함께 삭제하지 않고는` 어떤 정보를 삭제하는 것이 불가능




🦒정규화를 통해 **갱신 이상(Update Anomaly)** 문제를 **크게 줄일 수 있다.**

## 2.3 나쁜 설계 예제

![image.png](/images/2024-12-1-database-normalization/image 1.png)

그림 7.1과 같은 구조와 내용을 갖는 사원 릴레이션으로부터 설계를 시작한다고 가정해보자. 

이 사원 릴레이션은 사원에 관한 정보를 저장하는 릴레이션이다. 

이 회사에서는 각 사원이 두개까지 부서에 속할 수 있다. ⇒ 문제

<aside>
🦒


### 🦒데이터 무결성 문제

- 부서 번호와 이름이 여러 컬럼에 분리되어 있어 일관성 유지가 어려움.
  - 예: `부서번호1`이 1일 때 `부서이름1`은 항상 "영업"이어야 하지만, 잘못된 값이 들어갈 위험이 있음.

### 확장성 부족

- 설계가 고정적이어서 **부서 개수가 가변적인 경우를 지원하지 못함**.
  - 3개 이상의 부서에 속한 사원을 표현하려면 테이블 구조를 변경해야 함.

## 2.4 나쁜 설계2 예제

![image.png](/images/2024-12-1-database-normalization/image 2.png)

위와 같이 설계하면, 각 사원마다 부서수를 제한할 필요가 없다. 그러나 이설계는 `또 다른 단점`을 가지고 있다. 

### 2.4.1 정보의 중복

각 사원이 속한 부서수만큼 동일한 사원의 투플들이 존재하므로,

사원이름, 사원번호, 주소, 전화번호등이 중복되어 저장공간이 낭비된다.

### 2.4.2 수정이상

만일 어떤 부서의 이름이 바뀔때 이 부서에 근무하는 일부 사원 투플에서만 부서이름을 변경하면,

데이터베이스가 불일치 상태에 빠짐

### 2.4.3 삽입이상

만일 어떤 부서를 신설했는데, 아직 사원을 한명도 배정하지 않았다면 이부서에 관한 정보를 입력할 수 없다.

### 2.4.4 삭제이상

만일 어떤 부서에 속한 사원이 단 한명이 있는데, 이 사원에 관한 투플을 삭제하면 이 사원이 속한 부서에 관한 정보도 릴레이션에서 삭제된다.

## 2.5 릴레이션 분해

하나의 릴레이션을 두개 이상의 릴레이션으로 나눔

릴레이션 분해는 필요한 경우에는 분해된 릴레이션들로부터 원래의 릴레이션을 다시 구할 수 있음을 보장해야한다는 원칙을 기반

분해를 잘못하면 두 릴레이션으로부터 얻을 수 있는 정보가 원래의 릴레이션이 나타내던 정보보다 적을 수도 있고 많을 수도 있다.

두릴레이션으로부터 얻을 수 있는 정보는 원래의 릴레이션이 갖고있던 정보와 정확하게 일치해야한다.

릴레이션의 분해는 릴레이션에 존재하는 함수적 종석성에 관한 지식을 기반으로 한다.

예)

<img src="/images/2024-12-1-database-normalization/image 3.png" alt="image.png" style="zoom:67%;" />

위의 테이블을 다음과 같이 분해하였다. 

![image.png](/images/2024-12-1-database-normalization/image 4.png)

### 부서이름의 수정

어떤 부서에 근무하는 사원이 여러명 있더라도 , 사원1릴레이션에는 부서이름이 포함되어있지 않으므로 수정이상이 나타나지 않는다.

### 새로운 부서를 삽입

만일 어떤 신설 부서에 사원이 한명도 배정되지 않았더라도, 부서 릴레이션의 기본 키가 부서번호이므로 이 부서에 관한 정보를 부서 릴레이션에 삽입할 수 있음.

사원이 한명이 없는 부서라도, 부서릴레이션이 따로 있으므로 → 부서 릴레이션에 부서에대한 정보를 삽입할 수 있다.

### 마지막 사원 투플을 삭제

만일 어느 부서에 속한 유일한 사원에 관한 투플을 삭제하더라도, 이부서에 관한 정보는 부서 릴레이션에 남아있다.

## 2.6 정규형의 종류

- 제1정규형(first normal form)
- 제2정규형(second normal form)
- 제3정규형(third normal form)
- BCNF(Boyce-Codd normal form)
- 제4정규형(fourth normal form)
- 제5정규형(fifth normal form)

일반적으로 산업계의 데이터베이스 응용에서 데이터베이스를 설계할 때 BCNF까지만 고려함

## 2.7 관계 데이터베이스 설계의 비공식적인 지침

### 지침1: 이해하고 쉽고 명확한 스키마를 만들라

`여러 엔티티 타입이나 관계 타입에 속한 애트리뷰트들을 하나의 릴레이션에 포함시키지 않음.` 

**스키마 예시**

![image.png](/images/2024-12-1-database-normalization/image 5.png)

### 지침2: 널값을 피하라

### 지침3: 가짜 투플이 생기지 않도록하라.

### 지침4: 스키마를 정제하라.

# 3. 함수적 종속성

어떤 애트리뷰트가 다른 애트리뷰트에 의해 결정되는것

## 3.1 결정자 (determinent)

어떤 애트리뷰트의 값은 다른 애트리뷰트의 값을 고유하게 결정할 수 있음

![image.png](/images/2024-12-1-database-normalization/image 6.png)

위의 릴레이션에서 

사원릴레이션에서 `사원번호`는 사원이름을 고유하게 결정한다.

또한 `사원번호`는 주소와 전화번호도 고유하게 결정한다. 

`주소`는 사원이름을 고유하게 결정하지 못함.

| `결정자`  | 종속되어있는 요소 |
| --------- | ----------------- |
| 사원번호→ | 사원이름          |
| 사원번호→ | 주소              |
| 사원번호→ | 전화번호          |
| 부서번호→ | 부서이름          |

## 3.2 함수적 종속성

만일 애트리뷰트 A가 애트리뷰트 B의 결정자이면 , `(A → B)`

B가 A에 함수적으로 종속한다고 말한다.

다른 말로 표현하면, 주어진 릴레이션 R에서 

애트리뷰트 B가 애트리뷰트 A에 `함수적으로 종속`하는 필요충분조건은

A값에 대해 반드시 한개의 B값이 대응된다는것

하나의 함수적 종속성은 실세계의 의미에 따라 바뀜

예)

![image.png](/images/2024-12-1-database-normalization/image 7.png)

사원번호 → 사원이름, 주소, 전화번호

`직책은 (사원번호, 부서번호)에 함수적으로 종속하지,` 사원번호에 함수적으로 종속하지는 않는다.

(사원번호,부서번호) → 직책

사원번호 → X 직책




### 🦒데이터 예시:

| 사원번호 | 부서번호 | 직책 |
| -------- | -------- | ---- |
| 2106     | 1        | 대리 |
| 2106     | 2        | 팀장 |
| 3426     | 3        | 과장 |

- **사원번호만으로 결정되지 않는 이유**:
  - 사원번호 `2106`만 보면, 해당 사원이 부서 1에서는 `대리`이고, 부서 2에서는 `팀장`임.
  - 따라서, **부서번호**를 함께 알아야 직책이 정확히 결정됨.
- **(사원번호, 부서번호)가 결정자로 작동**:
  - `사원번호`와 `부서번호`를 모두 알면 해당 사원의 직책을 정확히 알 수 있음.
  - 예: (2106, 1) → 대리, (2106, 2) → 팀장.
    

## 3.3 완전 함수적 종속성 (FFD)

Full Functional Dependency

주어진 릴레이션 R에서 애트리뷰트 B가 애트리뷰트 A에 함수적으로 종속하면서,  (A→B)

애트리뷰트 A의 어떠한 진부분 집합에도 함수적으로 종속하지 않으면, (X→A)

`애트리뷰트 B가 애트리뷰트A에 완전하게 함수적으로 종속한다고 말함. (B->A)`

![image.png](/images/2024-12-1-database-normalization/image 8.png)

### `부분 함수적 종속성`: 기본키의 일부만으로 속성이 결정되는 경우

예시:

- 즉, 기본 키 전체가 아닌 **'사원번호'만으로 충분히 결정 가능한 속성**들이 존재.

### `완전 함수적 종속성` : 속성이 **기본키 전체에 의해 유일하게 결정되는 경우**

직책은 (사원번호, 부서번호)로만 완전히 결정될 수 있음.

![image.png](/images/2024-12-1-database-normalization/image 9.png)

## 3.4 이행적 함수적 종속성

**조건**: 속성 A, B, C가 있을 때, A가 B를 결정하고(B는 A에 종속), B가 C를 결정하면(C는 B에 종속), C는 **이행적으로 A에 종속**된다.

- 표기: A→B ∧ B→C⇒A→C

**이행적 종속성의 특징**:

- A→C는 직접적인 종속이 아니라, **B를 거쳐서 간접적으로 성립**한다.

<aside>
🦒

`직접적인 종속이 아니라, 한단계를 건너뛰어서 간접적으로 성립한다.`



![image.png](/images/2024-12-1-database-normalization/image 10.png)

여기서 fd2는 이행적 함수적 종속성이다.

# 4. 릴레이션 분해

하나의 릴레이션을 두개 이상의 릴레이션으로 나눈다.

릴레이션을 분해하면 중복이 감소되고 갱신이상이 줄어드는 장점이 있는 반면,

바람직한 문제들을 포함하여 몇가지 잠재적인 문제들을 야기할 수 있다.

- 릴레이션이 분해되기전: 조인이 필요없었던 질의
- → 분해후: 조인을 필요로 하는 질의로 바뀔수 있다.

어떤 종속성을 검사하기 위해서는 분해된 릴레이션들의 조인이 필요할 수있다.

## 4.1 무손실 분해

분해된 두 릴레이션을 조인하면 원래의 릴레이션에 들어있는 정보를 완전하게 얻을 수있다.

(여기서 손실이란 정보의 손실을 뜻한다.)

정보의 손실은 원래의 릴레이션을 분해한후에 생성된 릴레이션들을 조인한 결과에 들어있는 정보가 , 원래의 릴레이션에 들어있는 정보보다 `적거나 많은것을 모두 포함한다.`(→ 원래의 릴레이션 =X 분해된 릴레이션)

### 4.1.1 릴레이션 분해 예제

![image.png](/images/2024-12-1-database-normalization/image 11.png)

학번 → 이름, 이메일

이메일 → 학번, 이름

(학번, 과목번호) → 학점 

![image.png](/images/2024-12-1-database-normalization/image 12.png)

**분해 이유:**

- 학번을 기준으로 학생의 기본 정보와 수강 정보를 분리하여 데이터 중복을 제거하고 효율성을 높임.
- 학번은 학생 릴레이션에서 **기본 키**이며, 수강 릴레이션에서는 **외래 키**로 사용됨.

### 장점

- 데이터 중복 제거: 학생의 이름, 이메일 등이 중복 저장되지 않음.
- 갱신 이상 방지: 학생의 이메일을 변경해도 수강 릴레이션에 영향을 미치지 않음.
- 삽입 이상 방지: 학생 정보를 입력하지 않고도 수강 정보를 추가할 수 있음

![image.png](/images/2024-12-1-database-normalization/image 13.png)

굳이 이렇게 한번 더 나눌필요는 없다.

- **데이터 조인 필요성 증가**:
  - 학생 이름과 이메일 정보를 확인하려면 두 릴레이션을 항상 조인해야 하므로 성능이 저하될 수 있음.
- **설계 불필요성**:
  - 원래 테이블에 데이터 중복이 없기 때문에 이렇게 분리할 이유가 없음.

![과도하게 분해한 나쁜 분해](/images/2024-12-1-database-normalization/image 14.png)

과도하게 분해한 나쁜 분해

- 원래 테이블에서 학번을 기준으로 수강 정보(과목번호, 학점)를 저장했지만, 이를 잘못 분해하여 학번을 중심으로 각각 과목번호와 학점을 따로 저장.

### 문제점

1. **데이터 무결성 손실**:
   - 과목번호와 학점의 관계가 깨져버림.
   - 예: 학생이 어떤 과목에서 얻은 학점을 알 수 없게 됨.
2. **데이터 의미 손실**:
   - 분해된 릴레이션만으로는 원래의 수강 테이블이 표현하는 정보를 복구할 수 없음.
3. **잘못된 설계**:
   - 관계를 유지하려면 원래 테이블처럼 `학번, 과목번호, 학점`을 모두 함께 저장해야 함.

### 4.1.2 나쁜분해를 다시 조인 → 가짜 튜플

- **정의**: 릴레이션(테이블)을 잘못 분해한 뒤, 이를 다시 조인(Join)했을 때 **원래는 존재하지 않는 데이터(가짜 데이터)**가 생성되는 현상.
- **원인**: 릴레이션 분해 시, 속성 간의 함수적 종속성을 유지하지 못했거나, 분해된 릴레이션 간의 관계를 제대로 관리하지 못한 경우 발생.
- **결과**: 데이터베이스의 무결성이 깨지고, 잘못된 정보가 저장되거나 반환될 수 있음.

<img src="/images/2024-12-1-database-normalization/image 15.png" alt="image.png" style="zoom:50%;" />

# 5. 정규화의 단계

![image.png](/images/2024-12-1-database-normalization/image 16.png)

## 5.1 제 1정규형



🦒특징 요약:
릴레이션R의 모든 애트리뷰트가 원자값만을 갖는다는것
부분 함수적 종속성이 존재하는 릴레이션`(제1 정규형)`

제1정규형으로 변환하는 방법:
`반복 그룹 애트리뷰트에 나타나는 집합에 속한 각 값마다 하나의 투플로 표현`
`모든 반복 그룹 애트리뷰트들을 분리, 새로운 릴레이션으로 넣음.`

`원래 릴레이션의 기본 키를 새로운 릴레이션에 애트리뷰트로 추가함`🦒



한 릴레이션 R이 제1정규형을 만족할 필요충분조건은 

→`릴레이션R의 모든 애트리뷰트가 원자값만을 갖는다는것`!!!!!!!!!!!!!

→ 즉, 릴레이션의 모든 애트리뷰트에 반복 그룹이 나타나지 않으면 제 1정규형을 만족함.

<img src="/images/2024-12-1-database-normalization/image 17.png" alt="image.png" style="zoom:50%;" />

**반복 그룹**:

- `과목번호` 속성에 `{CS310, CS313}` 또는 `{CS310, CS345}`와 같은 **중복된 값(컬렉션 형태)**이 저장되어 있습니다.
- 이는 하나의 속성(셀)에 여러 값을 포함한 **비원자값(Non-Atomic Value)**으로, 제1정규형을 위반한 상태입니다.

### 5.1.1 제 1정규형으로 변환하는 방법 1

`반복 그룹 애트리뷰트에 나타나는 집합에 속한 각 값마다 하나의 투플로 표현`

문제: 과목번호 때문에 다른 값들이 두번씩 적혀있다.

<img src="/images/2024-12-1-database-normalization/image 18.png" alt="image.png" style="zoom:50%;" />

### 5.1.2 제 1정규형으로 변환하는 방법 2

- `모든 반복 그룹 애트리뷰트들을 분리, 새로운 릴레이션으로 넣음.`
- `원래 릴레이션의 기본 키를 새로운 릴레이션에 애트리뷰트로 추가함`

<img src="/images/2024-12-1-database-normalization/image 19.png" alt="image.png" style="zoom:50%;" />

### 5.1.3  제 1정규형 만족

- 다음 학생 릴레이션은 모든 애트리뷰트가 원자값을 가지므로 제 1정규형을 만족한다.
- 이 릴레이션의 기본 키는 (학번, 과목번호)

<img src="/images/2024-12-1-database-normalization/image 20.png" alt="image.png" style="zoom:50%;" />

### 5.1.4  하지만, 제 1정규형에 존재하는 갱신 이상

**수정 이상**

- 한 학과에 소속한 학생 수만큼 그 학과의 전화번호가 중복되어 저장되므로 여러 학생이 소속된 `학과의 전화번호가 변경되었을 때` 그 학과에 소속된 모든 학생들의 튜플에서 전화번호를 수정하지 않으면 데이터베이스의 일관성이 유지되지 않음.

**삽입 이상**

- 학번, 과목번호가 기본키이므로 둘중 하나가 없으면 해당 릴레이션에 삽입할 수 없다.

**삭제 이상**

- 어떤 학과에 소속된 마지막 학생 튜플을 삭제하면 이 학생이 소속된 학과에 관한 정보도 삭제됨.

### 5.1.5 제 1정규형과 제 2정규형

<img src="/images/2024-12-1-database-normalization/image 21.png" alt="image.png" style="zoom:50%;" />

부분 함수적 종속성이 존재하는 릴레이션`(제1 정규형)`

<img src="/images/2024-12-1-database-normalization/image 22.png" alt="image.png" style="zoom:50%;" />

`부분 함수적 종속성이 존재하지 않도록 분해된` 두 릴레이션 (제2정규형)

## 5.2 제2정규형

🦒특징요약:
`부분 함수적 종속성이 존재하지 않도록 분해된` 두 릴레이션 (제2정규형)

`릴레이션R이 제1정규형을 만족하면서`, 어떤 후보키에도 속하지 않는 모든 애트리뷰트들이 R의 기본키에 완전하게 함수적으로 종속하는것

기본키가 한개인 애트리뷰트로 이루어진 릴레이션 → 자동으로 제2정규형 만족

이행적종속성은 존재할 수 있다.🦒





한 릴레이션R이 제2정규형을 만족할 필요충분 조건은 

`릴레이션R이 제1정규형을 만족하면서`, 어떤 후보키에도 속하지 않는 모든 애트리뷰트들이 R의 기본키에 완전하게 함수적으로 종속하는것

`기본키가 두개 이상의 애트리뷰트로 구성되었을 경우에만`=> 제 1정규형이 제 2정규형을 만족하는가를 고려할 필요가 있음

`즉 기본키가 한개의 애트리뷰트로 이루어진 릴레이션`이 ⇒ 제 1정규형을 만족하면 제 2정규형을 만족

### 5.2.1 제2정규형 만족

학생1릴레이션의 기본키는 한 애트리뷰트인 학번이므로 제2정규형을 만족한다.

<img src="/images/2024-12-1-database-normalization/image 23.png" alt="image.png" style="zoom:50%;" />

### 5.2.2 제2정규형에 존재하는 갱신이상

**수정 이상**

- 여러 학생이 소속된 학과의 전화번호가 변경되었을 때 그 학과에 소속된 모든 학생들의 튜플에서 전화번호를 수정하지 않으면 데이터베이스의 일관성이 유지되지 않음.

**삽입 이상**

- 어떤 학과를 신설해서 아직 소속 학생이 없으면 그 학과의 정보를 입력할 수 없음. 왜냐하면 학번이 기본 키인데 엔티티 무결성 제약조건에 따라 기본 키에 널값을 입력할 수 없기 때문.

**삭제 이상**

- 어떤 학과에서 마지막 학생의 튜플이 삭제되면 그 학과의 전화번호도 함께 삭제됨.

이행적 종속성이 존재하는 릴레이션 `( 제2정규형)`

<img src="/images/2024-12-1-database-normalization/image 24.png" alt="image.png" style="zoom:50%;" />

이행적 종속성이 존재하지 않도록 분해된 두 릴레이션(제3정규형)

<img src="/images/2024-12-1-database-normalization/image 25.png" alt="image.png" style="zoom:50%;" />

## 5.3 제3정규형

<aside>
🦒


🦒릴레이션R이 제2정규형을 만족하면서, 

`키가 아닌 모든 애트리뷰트가, 릴레이션R의 기본키에 이행적으로 종속하지 않는것`

`키가 아닌 강사 애트리뷰트가 기본 키에 완전하게 함수적으로 종속하므로 제2정규형을 만족하고`, `키가 아닌 모든 애트리뷰트가 기본 키에 직접 종속하므로 제3정규형도 만족함.`🦒







한 릴레이션R이 제3정규형을 만족할 필요 충분조건은

 릴레이션R이 제2정규형을 만족하면서, 

`키가 아닌 모든 애트리뷰트가,  릴레이션R의 기본키에 이행적으로 종속하지 않는것`

### 5.3.1 제 3정규형

<img src="/images/2024-12-1-database-normalization/image 26.png" alt="image.png" style="zoom:50%;" />

- 그림 7.20의 수강 릴레이션에서 각 학생은 여러 과목을 수강할 수 있고, 각 강사는 한 과목만 가르침. 이 릴레이션의 기본 키는 (학번, 과목).
- `키가 아닌 강사 애트리뷰트가 기본 키에 완전하게 함수적으로 종속하므로 제2정규형을 만족하고`, `키가 아닌 강사 애트리뷰트가 기본 키에 직접 종속하므로 제3정규형도 만족함.`
- 이 릴레이션에는 아래와 같은 함수적 종속성들이 존재함:
  - (학번, 과목) → 강사
  - 강사 → 과목

<img src="/images/2024-12-1-database-normalization/image 27.png" alt="image.png" style="zoom:50%;" />

### 5.3.2 제 3정규형에 존재하는 갱신 이상

**수정 이상**

- 여러 학생이 수강 중인 어떤 과목의 강사가 변경되었을 때 그 과목을 수강하는 모든 학생들의 튜플에서 강사를 수정하지 않으면 데이터베이스의 일관성이 유지되지 않음.

  (과목의 강사가 변경되었을때, 학생들의 강사를 수정해야함)

**삽입 이상**

- 어떤 과목을 신설하여 아직 수강하는 학생이 없으면 그 과목의 강사가 그 과목을 가르친다는 정보를 입력할 수 없음. 왜냐하면 학번이 기본 키를 구성하는 애트리뷰트인데 엔티티 무결성 제약조건에 따라 기본 키를 구성하는 애트리뷰트에 널값을 입력할 수 없기 때문.

**삭제 이상**

- 어떤 과목을 이수하는 학생이 한 명밖에 없는데 이 학생의 튜플을 삭제하면 그 과목을 가르치는 강사에 관한 정보도 함께 삭제됨.

### 5.3.3 제 3정규형에 존재하는 갱신 이상이 생기는 이유

- 수강 릴레이션에서 키가 아닌 애트리뷰트가 다른 애트리뷰트를 결정하기 때문.
- 이 릴레이션의 후보 키는 (학번, 과목)과 (학번, 강사).

## 5.4 BCNF

BCNF는 **정규화의 한 단계**로, 데이터베이스에서 이상(Anomaly)을 최소화하고 무결성을 보장하기 위해 제안된 정규화 형태. **제3정규형(3NF)**보다 더 엄격한 조건을 적용

### **5.4.1 BCNF로 정규화하는 과정**

1. **제3정규형을 만족하는 릴레이션을 BCNF로 정규화**:
   - 키가 아니면서 결정자 역할을 하는 애트리뷰트와 그 결정자에 함수적으로 종속하는 애트리뷰트를 하나의 새로운 테이블에 분리합니다.
   - 이렇게 하면, 모든 결정자가 **후보 키**가 되도록 보장합니다.
2. **결정자의 역할**
   - 새로운 테이블에서 결정자는 기본 키로 사용됩니다.
   - 기존 릴레이션에 남아 있는 결정자는 **외래 키(Foreign Key)** 역할을 합니다.

---

### **요약**

- BCNF 정규화는 결정자가 후보 키가 아니면서도 다른 속성을 결정하는 문제를 해결합니다.
- 정규화 후, `결정자는 새로운 릴레이션에서 기본 키가 되며`, 원래 릴레이션에서는 외래 키 역할을 합니다. 이를 통해 데이터베이스의ㅁ 무결성과 갱신 이상을 방지할 수 있습니다.

### **5.4.2  BCNF란?**

**그림 7.22: 제3정규형을 만족하지만 BCNF는 만족하지 않는 릴레이션**

<img src="/images/2024-12-1-database-normalization/image 28.png" alt="image.png" style="zoom:50%;" />

- **(a) 애트리뷰트가 세 개인 경우**:
  - 릴레이션은 `A → C`와 같은 함수적 종속성을 가지며 제3정규형(3NF)을 만족합니다.
  - `하지만, **결정자 A가 후보 키가 아니기 때문에 BCNF를 만족하지 못합니다.**`
- **(b) 애트리뷰트가 네 개인 경우**:
  - 릴레이션은 `C → B`와 같은 함수적 종속성을 가지며 제3정규형을 만족합니다.
  - 그러나, `결정자 C 역시 후보 키가 아니기 때문에 BCNF를 만족하지 못합니다.`

**그림 7.23: 제3정규형을 BCNF로 분해**

<img src="/images/2024-12-1-database-normalization/image 29.png" alt="image.png" style="zoom:50%;" />

- **(a) 애트리뷰트가 세 개인 경우**:
  - 릴레이션을 BCNF로 분해하여 `A → C`의 종속성을 해결합니다.
  - 결과:
    1. 릴레이션1: `A, C` (A는 C를 결정)
    2. 릴레이션2: `C, B` (C는 B를 결정)
- **(b) 애트리뷰트가 네 개인 경우**:
  - 릴레이션을 BCNF로 분해하여 `C → B`의 종속성을 해결합니다.
  - 결과:
    1. 릴레이션1: `A, C, D` (A는 C와 D를 결정)
    2. 릴레이션2: `C, B` (C는 B를 결정)

### **5.4.2  BCNF의 핵심!!!**

- 제3정규형은 모든 비키 속성이 기본 키에 완전 함수적으로 종속되도록 보장하지만, `결정자가 후보 키가 아닌 경우 BCNF를 만족하지 못합니다.`
- **`BCNF는 모든 결정자가 후보 키여야 한다는 추가 조건을 충족시킵니다.`**
- BCNF로 분해하면 갱신 이상과 같은 문제가 사라지며, 데이터의 무결성이 더욱 강화됩니다.

### **5.4.3 제3정규형을 BCNF로 정규화 예시**

![image.png](/images/2024-12-1-database-normalization/image 30.png)

**상황 설명**

- 원래의 수강 릴레이션에서는 `강사 → 과목`이라는 함수적 종속성이 존재합니다.
- 하지만 `강사`는 후보 키가 아니기 때문에 BCNF 조건을 만족하지 않습니다.
- 따라서 이 릴레이션을 BCNF로 정규화하여 갱신 이상 문제를 해결합니다.

---

### **정규화 과정**

1. **원래 릴레이션**
   - 속성: `학번`, `과목`, `강사`
   - 함수적 종속성:
     - `학번, 과목 → 강사` (후보 키)
     - `강사 → 과목`
2. **BCNF로 정규화**
   - `강사 → 과목`의 종속성을 분리하여 두 개의 릴레이션으로 나눕니다.
   - 결과:
     - **수강1 릴레이션**: `학번`, `강사`
     - **수강2 릴레이션**: `강사`, `과목`

---

### **결과 릴레이션**

1. **수강1 릴레이션**
   - 속성: `학번`, `강사`
   - 설명: 각 학생(학번)이 어떤 강사에게 수강했는지를 나타냄.
   - 갱신 이상 방지: 강사가 바뀌거나 학생이 추가될 때 영향을 받지 않음.
2. **수강2 릴레이션**
   - 속성: `강사`, `과목`
   - 설명: 각 강사가 어떤 과목을 가르치는지를 나타냄.
   - 갱신 이상 방지: 강사의 과목 변경이 독립적으로 처리됨.

---

### **핵심 메시지**

- BCNF로 정규화함으로써 `강사 → 과목`이라는 함수적 종속성을 해결하여 데이터베이스의 무결성을 유지할 수 있습니다.
- 갱신 이상(수정, 삽입, 삭제)의 발생 가능성을 제거합니다.

## 5.4 정규화의 단계 정리

![image.png](/images/2024-12-1-database-normalization/image 31.png)

1. **비정규형 릴레이션**
   - **특징**: 데이터가 정규화되지 않은 상태.
   - **수행 작업**: 반복 그룹을 제거하여 제1정규형으로 변환.
2. **제1정규형**
   - **특징**: 모든 애트리뷰트가 원자값을 가짐(반복 그룹 제거).
   - **수행 작업**: 부분 함수적 종속성을 제거하여 제2정규형으로 변환.
3. **제2정규형**
   - **특징**: 제1정규형 + 기본 키가 아닌 모든 애트리뷰트가 기본 키에 완전 함수적 종속.
   - **수행 작업**: 이행적 종속성을 제거하여 제3정규형으로 변환.
4. **제3정규형**
   - **특징**: 제2정규형 + 기본 키가 아닌 모든 애트리뷰트가 기본 키에 직접 종속.
   - **수행 작업**: 후보 키가 아닌 결정자를 제거하여 BCNF로 변환.
5. **BCNF (Boyce-Codd Normal Form)**
   - **특징**: 제3정규형 + 모든 결정자가 후보 키.
   - **수행 작업**: 후보 키가 아닌 결정자를 가진 릴레이션을 추가적으로 분리.

---

**핵심 메시지**

- 정규화는 릴레이션의 비정규 상태에서 시작하여 각 단계마다 특정 이상(갱신 이상 등)을 제거하며 데이터의 무결성을 유지합니다.
- 각 단계마다 더 높은 무결성을 보장하며, 마지막 단계인 BCNF는 모든 결정자가 후보 키인 상태로 릴레이션을 분리합니다.
- BCNF를 만족하지 못할 경우 여전히 갱신 이상이 존재할 수 있기 때문에, 데이터베이스 설계에서는 가능하면 BCNF를 만족시키는 것이 중요합니다.

![image.png](/images/2024-12-1-database-normalization/image 32.png)

# 6. 역정규화

## 6.1 역정규화의 필요성

- 정규화 단계가 진행될수록 중복이 감소하고 갱신 이상도 감소됨

- 정규화가 진행될수록 무결성 제약조건을 시행하기 위해 필요한 코드의 양도 감소됨

- **역정규화 설명**

  - 정규화가 데이터베이스 설계의 중요한 요소이지만 성능상의 관점에서만 보면 높은 정규형을 만족하는 릴레이션 스키마가 최적인 것은 아님
  - 한 정규형에서 다음 정규형으로 진행될 때마다 하나의 릴레이션이 최소한 두 개의 릴레이션으로 분해됨
  - 분해되기 전의 릴레이션을 대상으로 질의를 할 때는 조인이 필요 없지만 `분해된 릴레이션을 대상으로 질의를 할 때는` 같은 정보를 얻기 위해서 보다 많은 릴레이션들을 접근해야 하므로 조인의 필요성이 증가됨

- 때로 데이터베이스 설계자는 응용의 요구 사항에 따라 데이터베이스 설계의 일부를 역정규화함으로써 데이터 중복 및 갱신 이상을 대가로 치르면서 성능상의 요구를 만족시키기도 함

- 많은 데이터베이스 응용에서 검색 질의의 비율이 갱신 질의의 비율보다 훨씬 높음.

  - `검색질의 > 갱신질의`

  `역정규화는 주어진 응용에서 빈번하게 수행되는 검색 질의들의 수행 속도를 높이기 위해서 이미 분해된 두 개 이상의 릴레이션들을 합쳐서 하나의 릴레이션으로 만드는 작업.`

- **`즉 역정규화는 보다 낮은 정규형으로 되돌아가는 것.`**

### (예: 조인의 필요성)

<img src="/images/2024-12-1-database-normalization/image 33.png" alt="image.png" style="zoom: 50%;" />

제2정규형을 만족하는 그림 7.18의 학생1 릴레이션에서 “학번이 11002인 학생이 속한 학과의 이름과 전화번호를 검색하라”는 질의를 아래와 같은 `SELECT`문으로 표현한다.

한 릴레이션에서 필요한 정보를 모두 찾을 수 있으므로 조인이 필요 없다.

```sql
SELECT 학과이름, 학과전화번호
FROM 학생1
WHERE 학번 = '11002';

```

![image-20241201012719786](/images/2024-12-1-database-normalization/image-20241201012719786.png)

(제3정규형) 

그러나 정규화 과정을 거쳐 그림 7.18의 릴레이션이 그림 7.19(b)처럼 두 개의 릴레이션으로 분해되면 동일한 정보를 찾기 위해 아래와 같이 **`조인**을 포함한 SELECT문이 사용`된다.

```sql
SELECT 학과이름, 학과전화번호
FROM 학생2, 학과
WHERE 학번 = '11002'
AND 학생2.학과이름 = 학과.학과이름;

```

![image-20241201012800177](/images/2024-12-1-database-normalization/image-20241201012800177.png)